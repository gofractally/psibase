#pragma once

#include <concepts>
#include <psibase/AccountNumber.hpp>
#include <psibase/Actor.hpp>
#include <psibase/Table.hpp>

namespace psibase
{
   /// Services may optionally inherit from this to gain the [emit] and [events] convenience methods
   ///
   /// Template arguments:
   /// - `DerivedService`: the most-derived service class that inherits from `Service`
   template <typename DerivedService>
   class Service
   {
     public:
      /// Emit events
      ///
      /// The following examples use the example definitions in [Defining Events](#defining-events). After you have defined your events, you can use `emit` to emit them. Examples:
      ///
      /// ```
      /// auto eventANumber = this->emit().history().myEvent(a, s);
      /// auto eventBNumber = this->emit().ui().updateDisplay();
      /// auto eventCNumber = this->emit().merkle().credit(from, to, amount);
      /// ```
      ///
      /// These functions return a `psibase::EventNumber`, aka `uint64_t`, which uniquely identifies the event. This number supports lookup; see [Service::events].
      ///
      /// `emit` is just a convenience method with the following definition:
      /// ```c++
      /// EventEmitter<DerivedService> emit() const
      /// {
      ///    return EventEmitter<DerivedService>();
      /// }
      /// ```
      ///
      /// Here's how to do the above when the service doesn't inherit from `psibase::Service`:
      ///
      /// ```
      /// EventEmitter<MyService> emitter;
      /// auto eventANumber = emitter.history().myEvent(a, s);
      /// auto eventBNumber = emitter.ui().updateDisplay();
      /// auto eventCNumber = emitter.merkle().credit(from, to, amount);
      /// ```
      EventEmitter<DerivedService> emit() const { return EventEmitter<DerivedService>(); }

      /// Read events
      ///
      /// The following examples use the example definitions in [Defining Events](#defining-events). After you have defined your events, you can use `events` to read them. Examples:
      ///
      /// ```
      /// auto eventAArguments = this->events().history().myEvent(eventANumber).unpack();
      /// auto eventBArguments = this->events().ui().updateDisplay(eventBNumber).unpack();
      /// auto eventCArguments = this->events().merkle().credit(eventCNumber).unpack();
      /// ```
      ///
      /// These functions take a `psibase::EventNumber`, aka `uint64_t`, which uniquely identifies the event. These numbers were generated by [Service::emit].
      ///
      /// The functions return `psio::shared_view_ptr<std::tuple<event argument types>>`. You can get the tuple using `unpack()`, like above.
      ///
      /// There are restrictions on when events can be read; see the following for details:
      ///
      /// - [DbId::historyEvent]
      /// - [DbId::uiEvent]
      /// - [DbId::merkleEvent]
      ///
      /// `events` is just a convenience method with the following definition:
      /// ```c++
      /// EventReader<DerivedService> events() const
      /// {
      ///    return EventReader<DerivedService>();
      /// }
      /// ```
      ///
      /// Here's how to do the above when the service doesn't inherit from `psibase::Service`:
      ///
      /// ```
      /// auto EventReader<MyService> reader;
      /// auto eventAArguments = reader.history().myEvent(eventANumber).unpack();
      /// auto eventBArguments = reader.ui().updateDisplay(eventBNumber).unpack();
      /// auto eventCArguments = reader.merkle().credit(eventCNumber).unpack();
      /// ```
      EventReader<DerivedService> events() const
      {
         return EventReader<DerivedService>(DerivedService::service);
      }
   };  // Service
};     // namespace psibase

#define PSIBASE_REFLECT_EVENTS(SERVICE)       \
   using SERVICE##_Events = SERVICE ::Events; \
   PSIO_REFLECT(SERVICE##_Events)

#define PSIBASE_REFLECT_HISTORY_EVENTS(SERVICE, ...)          \
   using SERVICE##_EventsHistory = SERVICE ::Events::History; \
   PSIO_REFLECT(SERVICE##_EventsHistory, __VA_ARGS__)

#define PSIBASE_REFLECT_UI_EVENTS(SERVICE, ...)     \
   using SERVICE##_EventsUi = SERVICE ::Events::Ui; \
   PSIO_REFLECT(SERVICE##_EventsUi, __VA_ARGS__)

#define PSIBASE_REFLECT_MERKLE_EVENTS(SERVICE, ...)         \
   using SERVICE##_EventsMerkle = SERVICE ::Events::Merkle; \
   PSIO_REFLECT(SERVICE##_EventsMerkle, __VA_ARGS__)
