package packages:plugin;

interface types {
    record package-ref {
        name: string,
        version: string,
    }
    /// Package metadata including where to fetch the package
    record package-info {
        name: string,
        version: string,
        description: string,
        depends: list<package-ref>,
        accounts: list<string>,
        sha256: string,
        file: string,
    }
    /// Package metadata
    record meta {
        name: string,
        version: string,
        description: string,
        depends: list<package-ref>,
        accounts: list<string>,
    }
    /// The location of a package repository.
    ///
    /// - If only `url` is provided, it means to use a static
    ///   package repository at that location
    /// - If only `account` is provided, it means to use an
    ///   account on this chain
    /// - If `account` and `url` are both provided, it means to
    ///   use an account on a foreign chain
    record package-source {
        url: option<string>,
        account: option<string>,
    }

    /// Specifies the default behavior for existing packages.
    /// Package dependencies and explicitly requested versions
    /// take precedence.
    enum package-preference {
        /// Prefer the highest version regardless of compatibility
        /// with the existing version
        best,
        /// Prefer semver compatible versions
        compatible,
        /// Prefer leaving the package unchanged
        current,
    }

    // Indicates that a package should be installed, removed, or replaced.
    record package-op-info {
        old: option<meta>,
        new: option<package-info>,
    }

    // Like package-op-info, but has the contents of the new package.
    record package-op-full {
        old: option<meta>,
        new: option<list<u8>>,
    }
}

interface private-api {
    use host:common/types.{error};
    use types.{meta, package-info, package-source, package-op-info, package-op-full, package-preference};

    // Takes a list of available packages and packages to install or update
    // and returns a list of operations to apply.
    resolve: func(index: list<package-info>, request: list<string>, request-pref: package-preference, non-request-pref: package-preference) -> result<list<package-op-info>, error>;

    // Returns two lists of transactions
    // - Upload package data. These transactions should be executed
    //   by passing them to push-data. The order of execution does not
    //   matter.
    // - Install packages. These must be staged with propose-install
    //   after all the data transactions are completed. This will usually
    //   only have one transaction, but it's possible to have more when
    //   installing many packages at once.
    //
    // The format of the result is unspecified. The transactions returned
    // should only be passed to push-data and stage-install.
    build-transactions: func(owner: string, packages: list<package-op-full>, compression-level: u8) -> result<tuple<list<list<u8>>, list<list<u8>>>, error>;

    push-data: func(tx: list<u8>);
    propose-install: func(tx: list<u8>) -> result<_, error>;
    set-account-sources: func(accounts: list<string>) -> result<_, error>;
}

interface queries {
    use host:common/types.{error};
    use types.{meta, package-source};
    get-installed-packages: func() -> result<list<meta>, error>;
    get-sources: func(owner: string) -> result<list<package-source>, error>;
}

world imports {
    import queries;
    import private-api;
}
