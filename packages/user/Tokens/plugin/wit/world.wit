package tokens:plugin;

interface types {
    /// A string that contains a decimal representation of a quantity of tokens, e.g. "10.1234"
    type decimal = string;
}

interface issuer {
    use host:types/types.{error};
    use types.{decimal};

    /// Create a new token
    ///
    /// Arguments
    /// * `precision` - Amount of decimal places in the token, 4 = 1.0000. 8 = 1.00000000
    /// * `max_supply` - The permanent max issued supply of the token
    create: func(precision: u8, max-supply: decimal) -> result<_, error>;

    /// Recall an amount of tokens from a user's balance and burn them.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `amount`   - Amount of tokens to recall
    /// * `memo`     - Memo describing the recall
    /// * `account`  - Account from which tokens are recalled
    recall: func(token-id: u32, amount: decimal, memo: string, account: string) -> result<_, error>;

    /// Mint new tokens into existence.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `amount`   - Amount of tokens to mint
    /// * `memo`     - Memo describing the mint
    mint: func(token-id: u32, amount: decimal, memo: string) -> result<_, error>;


    /// Configures whether a token should be transferable.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `enable`   - `true` to prevent transfers, `false` to allow them
    enable-token-untransferable: func(token-id: u32, enable: bool) -> result<_, error>;

    /// Configures whether a token should be able to be recalled by the token issuer.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `enable`   - `true` to prevent recalls, `false` to allow them
    enable-token-unrecallable: func(token-id: u32, enable: bool) -> result<_, error>;
}

interface user {
    use host:types/types.{error};
    use types.{decimal};

    /// Credit tokens to a recipient.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `debitor` - Debitor / recipient account
    /// * `amount`   - Amount to credit
    /// * `memo`     - Memo describing the credit
    ///
    /// Places funds in shared balance when the debitor has manual debit enabled
    credit: func(token-id: u32, debitor: string, amount: decimal, memo: string) -> result<_, error>;

    /// Cancel a pending shared-balance credit.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `debitor`  - Debitor / recipient account
    /// * `amount`   - Amount to uncredit
    /// * `memo`     - Memo describing the uncredit
    uncredit: func(token-id: u32, debitor: string, amount: decimal, memo: string) -> result<_, error>;

    /// Move tokens from shared balance into the debitor's account balance.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `creditor` - Account that initiated the credit
    /// * `amount`   - Amount to debit
    /// * `memo`     - Memo describing the debit
    debit: func(token-id: u32, creditor: string, amount: decimal, memo: string) -> result<_, error>;

    /// Reject all shared-balance tokens from a creditor.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `creditor` - Account that initiated the credit
    /// * `memo`     - Memo describing the rejection
    reject: func(token-id: u32, creditor: string, memo: string) -> result<_, error>;

    /// Burn tokens from the caller's balance.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `amount`   - Amount to burn
    /// * `memo`     - Memo describing the burn
    burn: func(token-id: u32, amount: decimal, memo: string) -> result<_, error>;
}

interface user-config {
    use host:types/types.{error};

    /// Enable or disable manual debit globally for the caller.
    ///
    /// Arguments
    /// * `enable` - `true` to require manual debit, `false` for automatic debit
    enable-user-manual-debit: func(enable: bool) -> result<_, error>;

    /// Keep zero balances globally for the caller.
    ///
    /// Arguments
    /// * `enable` - `true` to retain zero-balance rows, `false` to prune them
    enable-user-keep-zero-balances: func(enable: bool) -> result<_, error>;

    /// Enable manual debit for a specific token balance.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `enable`   - `true` to require manual debit, `false` for automatic debit
    enable-balance-manual-debit: func(token-id: u32, enable: bool) -> result<_, error>;

    /// Keep zero balances for a specific token balance.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    /// * `enable`   - `true` to retain zero-balance rows, `false` to prune them
    enable-balance-keep-zero-balances: func(token-id: u32, enable: bool) -> result<_, error>;

    /// Delete the caller's balance configuration for a token.
    ///
    /// Arguments
    /// * `token_id` - Unique token identifier
    del-balance-config: func(token-id: u32) -> result<_, error>;
}

interface helpers {
    use host:types/types.{error};
    use types.{decimal};

    /// Uses the precision of the specified token to convert from a token
    ///   decimal (string) to its u64 representation
    ///   (e.g. "100.0000" -> 1000000)
    decimal-to-u64: func(token-id: u32, amount: decimal) -> result<u64, error>;

    /// Uses the precision of the specified token to convert from an u64 representation
    ///   of token decimal to a string representation
    ///   (e.g. 1000000 -> "100.0000")
    u64-to-decimal: func(token-id: u32, amount: u64) -> result<decimal, error>;
}

world imports {
    import types;
    import issuer;
    import user;
    import user-config;
    import helpers;
}