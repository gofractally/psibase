(function(){const r=document.createElement("link").relList;if(r&&r.supports&&r.supports("modulepreload"))return;for(const t of document.querySelectorAll('link[rel="modulepreload"]'))i(t);new MutationObserver(t=>{for(const n of t)if(n.type==="childList")for(const s of n.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&i(s)}).observe(document,{childList:!0,subtree:!0});function o(t){const n={};return t.integrity&&(n.integrity=t.integrity),t.referrerPolicy&&(n.referrerPolicy=t.referrerPolicy),t.crossOrigin==="use-credentials"?n.credentials="include":t.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function i(t){if(t.ep)return;t.ep=!0;const n=o(t);fetch(t.href,n)}})();const F="modulepreload",I=function(e){return"/loader/"+e},N={},O=function(r,o,i){let t=Promise.resolve();if(o&&o.length>0){const n=document.getElementsByTagName("link");t=Promise.all(o.map(s=>{if(s=I(s),s in N)return;N[s]=!0;const a=s.endsWith(".css"),h=a?'[rel="stylesheet"]':"";if(!!i)for(let f=n.length-1;f>=0;f--){const l=n[f];if(l.href===s&&(!a||l.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${s}"]${h}`))return;const c=document.createElement("link");if(c.rel=a?"stylesheet":F,a||(c.as="script",c.crossOrigin=""),c.href=s,document.head.appendChild(c),a)return new Promise((f,l)=>{c.addEventListener("load",f),c.addEventListener("error",()=>l(new Error(`Unable to preload CSS for ${s}`)))})}))}return t.then(()=>r()).catch(n=>{const s=new Event("vite:preloadError",{cancelable:!0});if(s.payload=n,window.dispatchEvent(s),!s.defaultPrevented)throw n})};var y;(function(e){e.Call="call",e.Reply="reply",e.Syn="syn",e.SynAck="synAck",e.Ack="ack"})(y||(y={}));var v;(function(e){e.Fulfilled="fulfilled",e.Rejected="rejected"})(v||(v={}));var R;(function(e){e.ConnectionDestroyed="ConnectionDestroyed",e.ConnectionTimeout="ConnectionTimeout",e.NoIframeSrc="NoIframeSrc"})(R||(R={}));var A;(function(e){e.DataCloneError="DataCloneError"})(A||(A={}));var w;(function(e){e.Message="message"})(w||(w={}));const _=(e,r)=>{const o=[];let i=!1;return{destroy(t){i||(i=!0,r(`${e}: Destroying connection`),o.forEach(n=>{n(t)}))},onDestroy(t){i?t():o.push(t)}}},j=e=>(...r)=>{e&&console.log("[Penpal]",...r)},T=({name:e,message:r,stack:o})=>({name:e,message:r,stack:o}),x=e=>{const r=new Error;return Object.keys(e).forEach(o=>r[o]=e[o]),r},K=(e,r,o)=>{const{localName:i,local:t,remote:n,originForSending:s,originForReceiving:a}=e;let h=!1;const m=c=>{if(c.source!==n||c.data.penpal!==y.Call)return;if(a!=="*"&&c.origin!==a){o(`${i} received message from origin ${c.origin} which did not match expected origin ${a}`);return}const f=c.data,{methodName:l,args:d,id:p}=f;o(`${i}: Received ${l}() call`);const C=u=>g=>{if(o(`${i}: Sending ${l}() reply`),h){o(`${i}: Unable to send ${l}() reply due to destroyed connection`);return}const E={penpal:y.Reply,id:p,resolution:u,returnValue:g};u===v.Rejected&&g instanceof Error&&(E.returnValue=T(g),E.returnValueIsError=!0);try{n.postMessage(E,s)}catch(M){if(M.name===A.DataCloneError){const P={penpal:y.Reply,id:p,resolution:v.Rejected,returnValue:T(M),returnValueIsError:!0};n.postMessage(P,s)}throw M}};new Promise(u=>u(r[l].apply(r,d))).then(C(v.Fulfilled),C(v.Rejected))};return t.addEventListener(w.Message,m),()=>{h=!0,t.removeEventListener(w.Message,m)}};let V=0;const H=()=>++V,b=".",k=e=>e?e.split(b):[],B=e=>e.join(b),z=(e,r)=>{const o=k(r||"");return o.push(e),B(o)},U=(e,r,o)=>{const i=k(r);return i.reduce((t,n,s)=>(typeof t[n]>"u"&&(t[n]={}),s===i.length-1&&(t[n]=o),t[n]),e),e},D=(e,r)=>{const o={};return Object.keys(e).forEach(i=>{const t=e[i],n=z(i,r);typeof t=="object"&&Object.assign(o,D(t,n)),typeof t=="function"&&(o[n]=t)}),o},Y=e=>{const r={};for(const o in e)U(r,o,e[o]);return r},q=(e,r,o,i,t)=>{const{localName:n,local:s,remote:a,originForSending:h,originForReceiving:m}=r;let c=!1;t(`${n}: Connecting call sender`);const f=d=>(...p)=>{t(`${n}: Sending ${d}() call`);let C;try{a.closed&&(C=!0)}catch{C=!0}if(C&&i(),c){const u=new Error(`Unable to send ${d}() call due to destroyed connection`);throw u.code=R.ConnectionDestroyed,u}return new Promise((u,g)=>{const E=H(),M=S=>{if(S.source!==a||S.data.penpal!==y.Reply||S.data.id!==E)return;if(m!=="*"&&S.origin!==m){t(`${n} received message from origin ${S.origin} which did not match expected origin ${m}`);return}const $=S.data;t(`${n}: Received ${d}() reply`),s.removeEventListener(w.Message,M);let L=$.returnValue;$.returnValueIsError&&(L=x(L)),($.resolution===v.Fulfilled?u:g)(L)};s.addEventListener(w.Message,M);const P={penpal:y.Call,id:E,methodName:d,args:p};a.postMessage(P,h)})},l=o.reduce((d,p)=>(d[p]=f(p),d),{});return Object.assign(e,Y(l)),()=>{c=!0}},W=(e,r)=>{let o;return e!==void 0&&(o=window.setTimeout(()=>{const i=new Error(`Connection timed out after ${e}ms`);i.code=R.ConnectionTimeout,r(i)},e)),()=>{clearTimeout(o)}},Q=(e,r,o,i)=>{const{destroy:t,onDestroy:n}=o;return s=>{if(!(e instanceof RegExp?e.test(s.origin):e==="*"||e===s.origin)){i(`Child: Handshake - Received SYN-ACK from origin ${s.origin} which did not match expected origin ${e}`);return}i("Child: Handshake - Received SYN-ACK, responding with ACK");const h=s.origin==="null"?"*":s.origin,m={penpal:y.Ack,methodNames:Object.keys(r)};window.parent.postMessage(m,h);const c={localName:"Child",local:window,remote:window.parent,originForSending:h,originForReceiving:s.origin},f=K(c,r,i);n(f);const l={},d=q(l,c,s.data.methodNames,t,i);return n(d),l}},G=()=>{try{clearTimeout()}catch{return!1}return!0},J=(e={})=>{const{parentOrigin:r="*",methods:o={},timeout:i,debug:t=!1}=e,n=j(t),s=_("Child",n),{destroy:a,onDestroy:h}=s,m=D(o),c=Q(r,m,s,n),f=()=>{n("Child: Handshake - Sending SYN");const d={penpal:y.Syn},p=r instanceof RegExp?"*":r;window.parent.postMessage(d,p)};return{promise:new Promise((d,p)=>{const C=W(i,a),u=g=>{if(G()&&!(g.source!==parent||!g.data)&&g.data.penpal===y.SynAck){const E=c(g);E&&(window.removeEventListener(w.Message,u),C(),d(E))}};window.addEventListener(w.Message,u),f(),h(g=>{window.removeEventListener(w.Message,u),g&&p(g)})}),destroy(){a()}}};document.querySelector("#app").innerHTML=`
  <div>
    <h1>App 2 / Loader</h1>
    <p>This is a generated SPA designed to act as the loader, its sole purpose is to be rendered in an iframe and run a WASM Component, then execute functions in the WASM component and send the results back to its parent iframe.</p>
  </div>
`;const X=e=>typeof e=="object"&&e!==null&&"service"in e&&"method"in e&&"params"in e,Z=async e=>{if(!X(e))throw new Error("Invalid function call param.");const{load:r}=await O(()=>import("./index-mF64q04d.js"),__vite__mapDeps([])),i=await fetch("./loader/functions.wasm").then(n=>n.arrayBuffer()),t=await r(i);return console.log(t,"is the module I have"),t[e.method]()},ee=J({methods:{functionCall:Z}});ee.promise.then(e=>{e.add(3,1).then(r=>console.log(r))});export{O as _};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}