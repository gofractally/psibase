(function(){const o=document.createElement("link").relList;if(o&&o.supports&&o.supports("modulepreload"))return;for(const t of document.querySelectorAll('link[rel="modulepreload"]'))i(t);new MutationObserver(t=>{for(const n of t)if(n.type==="childList")for(const s of n.addedNodes)s.tagName==="LINK"&&s.rel==="modulepreload"&&i(s)}).observe(document,{childList:!0,subtree:!0});function r(t){const n={};return t.integrity&&(n.integrity=t.integrity),t.referrerPolicy&&(n.referrerPolicy=t.referrerPolicy),t.crossOrigin==="use-credentials"?n.credentials="include":t.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function i(t){if(t.ep)return;t.ep=!0;const n=r(t);fetch(t.href,n)}})();const F="modulepreload",I=function(e){return"/loader/"+e},b={},O=function(o,r,i){let t=Promise.resolve();if(r&&r.length>0){const n=document.getElementsByTagName("link");t=Promise.all(r.map(s=>{if(s=I(s),s in b)return;b[s]=!0;const a=s.endsWith(".css"),g=a?'[rel="stylesheet"]':"";if(!!i)for(let f=n.length-1;f>=0;f--){const l=n[f];if(l.href===s&&(!a||l.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${s}"]${g}`))return;const c=document.createElement("link");if(c.rel=a?"stylesheet":F,a||(c.as="script",c.crossOrigin=""),c.href=s,document.head.appendChild(c),a)return new Promise((f,l)=>{c.addEventListener("load",f),c.addEventListener("error",()=>l(new Error(`Unable to preload CSS for ${s}`)))})}))}return t.then(()=>o()).catch(n=>{const s=new Event("vite:preloadError",{cancelable:!0});if(s.payload=n,window.dispatchEvent(s),!s.defaultPrevented)throw n})};var y;(function(e){e.Call="call",e.Reply="reply",e.Syn="syn",e.SynAck="synAck",e.Ack="ack"})(y||(y={}));var v;(function(e){e.Fulfilled="fulfilled",e.Rejected="rejected"})(v||(v={}));var R;(function(e){e.ConnectionDestroyed="ConnectionDestroyed",e.ConnectionTimeout="ConnectionTimeout",e.NoIframeSrc="NoIframeSrc"})(R||(R={}));var A;(function(e){e.DataCloneError="DataCloneError"})(A||(A={}));var w;(function(e){e.Message="message"})(w||(w={}));const _=(e,o)=>{const r=[];let i=!1;return{destroy(t){i||(i=!0,o(`${e}: Destroying connection`),r.forEach(n=>{n(t)}))},onDestroy(t){i?t():r.push(t)}}},x=e=>(...o)=>{e&&console.log("[Penpal]",...o)},N=({name:e,message:o,stack:r})=>({name:e,message:o,stack:r}),j=e=>{const o=new Error;return Object.keys(e).forEach(r=>o[r]=e[r]),o},K=(e,o,r)=>{const{localName:i,local:t,remote:n,originForSending:s,originForReceiving:a}=e;let g=!1;const h=c=>{if(c.source!==n||c.data.penpal!==y.Call)return;if(a!=="*"&&c.origin!==a){r(`${i} received message from origin ${c.origin} which did not match expected origin ${a}`);return}const f=c.data,{methodName:l,args:d,id:p}=f;r(`${i}: Received ${l}() call`);const C=u=>m=>{if(r(`${i}: Sending ${l}() reply`),g){r(`${i}: Unable to send ${l}() reply due to destroyed connection`);return}const E={penpal:y.Reply,id:p,resolution:u,returnValue:m};u===v.Rejected&&m instanceof Error&&(E.returnValue=N(m),E.returnValueIsError=!0);try{n.postMessage(E,s)}catch(M){if(M.name===A.DataCloneError){const P={penpal:y.Reply,id:p,resolution:v.Rejected,returnValue:N(M),returnValueIsError:!0};n.postMessage(P,s)}throw M}};new Promise(u=>u(o[l].apply(o,d))).then(C(v.Fulfilled),C(v.Rejected))};return t.addEventListener(w.Message,h),()=>{g=!0,t.removeEventListener(w.Message,h)}};let V=0;const H=()=>++V,T=".",k=e=>e?e.split(T):[],B=e=>e.join(T),z=(e,o)=>{const r=k(o||"");return r.push(e),B(r)},U=(e,o,r)=>{const i=k(o);return i.reduce((t,n,s)=>(typeof t[n]>"u"&&(t[n]={}),s===i.length-1&&(t[n]=r),t[n]),e),e},D=(e,o)=>{const r={};return Object.keys(e).forEach(i=>{const t=e[i],n=z(i,o);typeof t=="object"&&Object.assign(r,D(t,n)),typeof t=="function"&&(r[n]=t)}),r},Y=e=>{const o={};for(const r in e)U(o,r,e[r]);return o},q=(e,o,r,i,t)=>{const{localName:n,local:s,remote:a,originForSending:g,originForReceiving:h}=o;let c=!1;t(`${n}: Connecting call sender`);const f=d=>(...p)=>{t(`${n}: Sending ${d}() call`);let C;try{a.closed&&(C=!0)}catch{C=!0}if(C&&i(),c){const u=new Error(`Unable to send ${d}() call due to destroyed connection`);throw u.code=R.ConnectionDestroyed,u}return new Promise((u,m)=>{const E=H(),M=S=>{if(S.source!==a||S.data.penpal!==y.Reply||S.data.id!==E)return;if(h!=="*"&&S.origin!==h){t(`${n} received message from origin ${S.origin} which did not match expected origin ${h}`);return}const $=S.data;t(`${n}: Received ${d}() reply`),s.removeEventListener(w.Message,M);let L=$.returnValue;$.returnValueIsError&&(L=j(L)),($.resolution===v.Fulfilled?u:m)(L)};s.addEventListener(w.Message,M);const P={penpal:y.Call,id:E,methodName:d,args:p};a.postMessage(P,g)})},l=r.reduce((d,p)=>(d[p]=f(p),d),{});return Object.assign(e,Y(l)),()=>{c=!0}},W=(e,o)=>{let r;return e!==void 0&&(r=window.setTimeout(()=>{const i=new Error(`Connection timed out after ${e}ms`);i.code=R.ConnectionTimeout,o(i)},e)),()=>{clearTimeout(r)}},Q=(e,o,r,i)=>{const{destroy:t,onDestroy:n}=r;return s=>{if(!(e instanceof RegExp?e.test(s.origin):e==="*"||e===s.origin)){i(`Child: Handshake - Received SYN-ACK from origin ${s.origin} which did not match expected origin ${e}`);return}i("Child: Handshake - Received SYN-ACK, responding with ACK");const g=s.origin==="null"?"*":s.origin,h={penpal:y.Ack,methodNames:Object.keys(o)};window.parent.postMessage(h,g);const c={localName:"Child",local:window,remote:window.parent,originForSending:g,originForReceiving:s.origin},f=K(c,o,i);n(f);const l={},d=q(l,c,s.data.methodNames,t,i);return n(d),l}},G=()=>{try{clearTimeout()}catch{return!1}return!0},J=(e={})=>{const{parentOrigin:o="*",methods:r={},timeout:i,debug:t=!1}=e,n=x(t),s=_("Child",n),{destroy:a,onDestroy:g}=s,h=D(r),c=Q(o,h,s,n),f=()=>{n("Child: Handshake - Sending SYN");const d={penpal:y.Syn},p=o instanceof RegExp?"*":o;window.parent.postMessage(d,p)};return{promise:new Promise((d,p)=>{const C=W(i,a),u=m=>{if(G()&&!(m.source!==parent||!m.data)&&m.data.penpal===y.SynAck){const E=c(m);E&&(window.removeEventListener(w.Message,u),C(),d(E))}};window.addEventListener(w.Message,u),f(),g(m=>{window.removeEventListener(w.Message,u),m&&p(m)})}),destroy(){a()}}};document.querySelector("#app").innerHTML=`
  <div>
    <h1>App 2 / Loader</h1>
    <p>This is a generated SPA designed to act as the loader, its sole purpose is to be rendered in an iframe and run a WASM Component, then execute functions in the WASM component and send the results back to its parent iframe.</p>
  </div>
`;const X=e=>typeof e=="object"&&e!==null&&"service"in e&&"method"in e&&"params"in e,Z=async e=>{if(!X(e))throw new Error("Invalid function call param.");const{load:o}=await O(()=>import("./index-zLtuILvr.js"),__vite__mapDeps([])),i=await fetch("/loader/functions.wasm").then(a=>a.arrayBuffer()),s=await o(i,[{"component:account-sys/imports":`export function prnt(string) {
    console.log('from imported code: ', string);
  };`}]);return console.log(s,"is the module I have"),s[e.method](...e.params)},ee=J({methods:{functionCall:Z}});ee.promise.then(e=>{e.add(3,1).then(o=>console.log(o))});export{O as _};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = []
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}