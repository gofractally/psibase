#[psibase::service_tables]
pub mod tables {
    use async_graphql::SimpleObject;

    use psibase::{AccountNumber, Fracpack, ToKey, ToSchema};
    use serde::{Deserialize, Serialize};

    #[table(name = "ConfigTable", index = 0)]
    #[derive(Serialize, Deserialize, ToSchema, Fracpack)]
    pub struct ConfigRow {
        pub owner: AccountNumber,
        pub last_used_id: u32,
    }

    impl ConfigRow {
        #[primary_key]
        fn pk(&self) -> &AccountNumber {
            &self.owner
        }
    }

    #[table(name = "EvaluationTable", index = 1)]
    #[derive(Default, Fracpack, ToSchema, SimpleObject, Serialize, Deserialize, Debug)]
    pub struct Evaluation {
        pub id: u32,
        pub created_at: u32,
        pub owner: AccountNumber,
        pub registration_starts: u32,
        pub deliberation_starts: u32,
        pub submission_starts: u32,
        pub finish_by: u32,
        pub use_hooks: bool,
        pub allowable_group_sizes: Vec<u8>,
        pub num_options: u8,
    }

    #[table(name = "UserTable", index = 2)]
    #[derive(Default, Fracpack, ToSchema, SimpleObject, Serialize, Deserialize, Debug, Clone)]
    pub struct User {
        pub owner: AccountNumber,
        pub evaluation_id: u32,
        pub user: AccountNumber,
        pub group_number: Option<u32>,
        pub attestation: Option<Vec<u8>>,
        pub proposal: Option<Vec<u8>>,
    }

    #[table(name = "GroupTable", index = 3)]
    #[derive(Default, Fracpack, ToSchema, SimpleObject, Serialize, Deserialize, Debug, Clone)]
    pub struct Group {
        pub owner: AccountNumber,
        pub evaluation_id: u32,
        pub number: u32,
        pub key_submitter: Option<AccountNumber>,
    }

    #[table(name = "UserSettingsTable", index = 4)]
    #[derive(Default, Fracpack, ToSchema, SimpleObject, Serialize, Deserialize, Debug, Clone)]
    pub struct UserSettings {
        #[primary_key]
        pub user: AccountNumber,
        pub key: Vec<u8>,
    }

    impl User {
        #[primary_key]
        pub fn pk(&self) -> &(AccountNumber, u32, AccountNumber) {
            &(self.owner, self.evaluation_id, self.user)
        }

        #[secondary_key(1)]
        pub fn by_group(&self) -> (AccountNumber, u32, Option<u32>, AccountNumber) {
            (self.owner, self.evaluation_id, self.group_number, self.user)
        }
    }

    impl Evaluation {
        #[primary_key]
        pub fn pk(&self) -> &(AccountNumber, u32) {
            &(self.owner, self.id)
        }
    }

    impl Group {
        #[primary_key]
        pub fn pk(&self) -> &(AccountNumber, u32, u32) {
            &(self.owner, self.evaluation_id, self.number)
        }
    }
}

pub mod impls {
    use super::tables::*;
    use crate::helpers::{
        calculate_results, get_current_time_seconds, EvaluationStatus, GroupResult,
    };
    use psibase::services::evaluations::Hooks::hooks_wrapper as EvalHooks;
    use psibase::services::subgroups::Wrapper as Subgroups;
    use psibase::{AccountNumber, Table};
    use rand::{rngs::StdRng, seq::SliceRandom, SeedableRng};

    impl ConfigRow {
        pub fn next_id(owner: AccountNumber) -> u32 {
            let table = ConfigTable::new();
            let mut config = table.get_index_pk().get(&&owner).unwrap_or(Self {
                owner,
                last_used_id: 0,
            });
            config.last_used_id += 1;
            table.put(&config).unwrap();
            config.last_used_id
        }
    }

    impl UserSettings {
        pub fn new(user: AccountNumber, key: Vec<u8>) -> Self {
            Self { user, key }
        }

        pub fn get(user: AccountNumber) -> Option<Self> {
            let table = UserSettingsTable::new();
            table.get_index_pk().get(&&user)
        }

        pub fn save(&self) {
            let table = UserSettingsTable::new();
            table.put(&self).unwrap();
        }
    }

    impl User {
        pub fn new(owner: AccountNumber, evaluation_id: u32, user: AccountNumber) -> Self {
            Self {
                owner,
                evaluation_id,
                user,
                group_number: None,
                attestation: None,
                proposal: None,
            }
        }

        pub fn add(owner: AccountNumber, evaluation_id: u32, user: AccountNumber) -> Self {
            let user = Self::new(owner, evaluation_id, user);
            user.save();
            user
        }

        pub fn get(owner: AccountNumber, evaluation_id: u32, user: AccountNumber) -> Option<Self> {
            UserTable::new()
                .get_index_pk()
                .get(&&(owner, evaluation_id, user))
        }

        fn save(&self) {
            UserTable::new().put(&self).unwrap();
        }

        pub fn delete(&self) {
            UserTable::new().remove(&self);
        }

        pub fn propose(&mut self, proposal: Vec<u8>) {
            self.proposal = Some(proposal);
            self.save();
        }

        pub fn attest(&mut self, attestation: Vec<u8>) {
            psibase::check(
                self.attestation.is_none(),
                format!("user {} has already submitted", self.user).as_str(),
            );

            self.attestation = Some(attestation);
            self.save();
        }

        pub fn set_group_number(&mut self, group_number: u32) {
            self.group_number = Some(group_number);
            self.save();
        }
    }

    impl Evaluation {
        fn new(
            allowable_group_sizes: Vec<u8>,
            registration_starts: u32,
            deliberation_starts: u32,
            submission_starts: u32,
            finish_by: u32,
            num_options: u8,
            use_hooks: bool,
        ) -> Self {
            let owner = psibase::get_sender();
            let created_at = get_current_time_seconds();
            let id = ConfigRow::next_id(owner);

            Self {
                id,
                owner,
                created_at,
                registration_starts,
                deliberation_starts,
                submission_starts,
                finish_by,
                use_hooks,
                allowable_group_sizes,
                num_options,
            }
        }

        fn calculate_scheduled_phase(&self, current_time_seconds: u32) -> EvaluationStatus {
            if current_time_seconds >= self.finish_by {
                EvaluationStatus::Closed
            } else if current_time_seconds >= self.submission_starts {
                EvaluationStatus::Submission
            } else if current_time_seconds >= self.deliberation_starts {
                EvaluationStatus::Deliberation
            } else if current_time_seconds >= self.registration_starts {
                EvaluationStatus::Registration
            } else {
                EvaluationStatus::Pending
            }
        }

        fn get_users(&self) -> Vec<User> {
            let table = UserTable::new();
            table
                .get_index_pk()
                .range(
                    &(self.owner, self.id, AccountNumber::new(0))
                        ..=&(self.owner, self.id, AccountNumber::new(u64::MAX)),
                )
                .collect()
        }

        fn save(&self) {
            let table = EvaluationTable::new();
            table.put(&self).unwrap();
        }

        fn notify_register(&self, registrant: AccountNumber) {
            if self.use_hooks {
                EvalHooks::call_from(crate::Wrapper::SERVICE).evalRegister(self.id, registrant);
            }
        }

        fn notify_unregister(&self, registrant: AccountNumber) {
            if self.use_hooks {
                EvalHooks::call_from(crate::Wrapper::SERVICE).evalUnregister(self.id, registrant);
            }
        }

        pub fn add(
            allowable_group_sizes: Vec<u8>,
            registration_starts: u32,
            deliberation_starts: u32,
            submission_starts: u32,
            finish_by: u32,
            num_options: u8,
            use_hooks: bool,
        ) -> Self {
            let evaluation = Self::new(
                allowable_group_sizes,
                registration_starts,
                deliberation_starts,
                submission_starts,
                finish_by,
                num_options,
                use_hooks,
            );
            evaluation.save();
            evaluation
        }

        pub fn get_groups(&self) -> Vec<Group> {
            let table = GroupTable::new();
            table
                .get_index_pk()
                .range(&(self.owner, self.id, 0)..=&(self.owner, self.id, u32::MAX))
                .collect()
        }

        pub fn get_group(&self, group_number: u32) -> Option<Group> {
            GroupTable::new()
                .get_index_pk()
                .get(&&(self.owner, self.id, group_number))
        }

        pub fn get(owner: AccountNumber, evaluation_id: u32) -> Self {
            EvaluationTable::new()
                .get_index_pk()
                .get(&&(owner, evaluation_id))
                .unwrap_or_else(|| panic!("Evaluation not found"))
        }

        pub fn delete(&self) {
            let table = EvaluationTable::new();
            table.remove(&self);
        }

        pub fn get_current_phase(&self) -> EvaluationStatus {
            self.calculate_scheduled_phase(get_current_time_seconds())
        }

        pub fn assert_status(&self, expected_status: EvaluationStatus) {
            let current_status = self.get_current_phase();
            psibase::check(
                current_status == expected_status,
                format!(
                    "Evaluation is in {:?} phase, expected {:?}",
                    current_status, expected_status
                )
                .as_str(),
            );
        }

        pub fn get_user(&self, user: AccountNumber) -> Option<User> {
            User::get(self.owner, self.id, user)
        }

        pub fn register_user(&self, new_user: AccountNumber) {
            self.assert_status(EvaluationStatus::Registration);
            User::add(self.owner, self.id, new_user);
            self.notify_register(new_user);
        }

        pub fn unregister_user(&self, user: AccountNumber) {
            self.assert_status(EvaluationStatus::Registration);
            if let Some(user) = User::get(self.owner, self.id, user) {
                user.delete();
                self.notify_unregister(user.user);
            }
        }

        pub fn create_groups(&self) {
            self.assert_status(EvaluationStatus::Deliberation);
            let users = self.get_users();
            let mut rng = StdRng::from_entropy();
            let mut users = users;
            users.shuffle(&mut rng);

            let mut group_sizes = self.allowable_group_sizes.clone();
            group_sizes.shuffle(&mut rng);

            let mut current_group = 0;
            let mut current_group_size = 0;
            let mut current_group_number = 0;

            for user in users {
                if current_group_size == 0 {
                    current_group_size = group_sizes[current_group];
                    current_group = (current_group + 1) % group_sizes.len();
                    current_group_number += 1;
                }

                let mut user = user;
                user.set_group_number(current_group_number);
                current_group_size -= 1;
            }
        }
    }

    impl Group {
        pub fn get(owner: AccountNumber, evaluation_id: u32, number: u32) -> Option<Self> {
            GroupTable::new()
                .get_index_pk()
                .get(&&(owner, evaluation_id, number))
        }

        pub fn save(&self) {
            let table = GroupTable::new();
            table.put(&self).unwrap();
        }

        pub fn delete(&self) {
            let table = GroupTable::new();
            table.remove(&self);
        }

        fn new(owner: AccountNumber, evaluation_id: u32, number: u32) -> Self {
            Self {
                owner,
                evaluation_id,
                number,
                key_submitter: None,
            }
        }

        pub fn add(owner: AccountNumber, evaluation_id: u32, number: u32) {
            let group = Self::new(owner, evaluation_id, number);
            group.save();
        }

        pub fn get_users(&self) -> Vec<User> {
            let table = UserTable::new();
            table
                .get_index_pk()
                .range(
                    &(self.owner, self.evaluation_id, AccountNumber::new(0))
                        ..=&(self.owner, self.evaluation_id, AccountNumber::new(u64::MAX)),
                )
                .filter(|user| user.group_number == Some(self.number))
                .collect()
        }

        pub fn get_result(&self) -> Option<Vec<u8>> {
            let users = self.get_users();
            if users.is_empty() {
                return None;
            }

            let mut results = Vec::new();
            for user in users {
                if let Some(proposal) = user.proposal {
                    results.push(proposal);
                }
            }

            if results.is_empty() {
                None
            } else {
                Some(calculate_results(results, self.evaluation_id))
            }
        }

        pub fn declare_result(&self, result: Vec<u8>) {
            let evaluation = Evaluation::get(self.owner, self.evaluation_id);
            evaluation.assert_status(EvaluationStatus::Submission);

            let users = self.get_users();
            for user in users {
                if user.attestation.is_none() {
                    panic!("Not all users have attested");
                }
            }

            let table = GroupTable::new();
            let mut group = self.clone();
            group.key_submitter = Some(psibase::get_sender());
            table.put(&group).unwrap();
        }

        pub fn set_key_submitter(&mut self, submitter: AccountNumber) {
            self.key_submitter = Some(submitter);
            self.save();
        }
    }
}
