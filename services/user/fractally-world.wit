interface fractally-types {
    record config {
        // @velua, you spent plenty of time on this for the Psinq UI. Would you fill in the minimal set of details we determined were necessary for meeting schedule?
    }
    record fractal-info {
        // What details do we need here as a "profile" for a fractal?
        name: string;
        bio: string;
        avatar: string;
        created-at: timestamp;
        status: enum<pre-evaluations, active, inactive>;
        num-members: u64;
    }
}

interface fractally {
    use fractally-types.{config};
    set-config: func(config: config) -> result<void, error>;
    get-fractal-info: func() -> result<fractal-info, error>;
    // I propose the periodic subj evaluation process is managed via FSM with this method to nudge it when needed (rather than numerous such do-the-next-thing methods)
    nudge: func() -> result<void, error>;
}

interface types-membership {
    record member-info {
        account: string;
        name: string;
        bio: string;
        avatar: string;
        invited-by: string;
        invited-at: timestamp;
        joined-at: timestamp;
        status: enum<invited, active, inactive, banned>;
        badges: list<string>; // Council, etc.
    }
}

interface membership {
    search-members: func(query: string) -> result<list<string>, error>;
    get-member-info: func(account: string) -> result<member-info, error>;
}

interface types-council {
    record petition {
        id: string;
        subject: string;
        body: string;
        stg-tx-id: option<string>; // push council-msig tx to staging area (to upgrade a system service)
        created-at: timestamp;
        deciders: list<string>;
        status: enum<open, approved, rejected>;
    }
    enum vote {
        approve;
        reject;
    }
}

interface council { // could become group-decision interface for *any* group of people, perhaps even the result of an evaluation
    use types-council.{petition, vote};

    create-petition: func(petition: petition) -> result<void, error>;
    vote: func(id: string, vote: vote) -> result<void, error>;
}

interface types-evaluations {
    record evaluation-info {
        // ...
    }
}
interface evaluations {
    use types-evaluations.{evaluation-info};
    get-evaluation-info: func(id: string) -> result<evaluation-info, error>;
    close-evaluations: func(id: string) -> result<void, error>;
    open-evaluations: func(id: string) -> result<void, error>;
    // ... @velua this is your domain. I'll leave this to you.

}

world imports {
    import fractally;
    import membership;
    import council;
}
